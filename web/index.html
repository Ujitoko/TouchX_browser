<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>TouchX Haptic Demo</title>
<style>
  body { margin: 0; overflow: hidden; background: #000000; }
  #status {
    position: fixed; top: 10px; left: 10px; z-index: 100;
    font: 14px/1.4 'Consolas', monospace; color: #aaa;
    background: rgba(0,0,0,0.6); padding: 8px 14px; border-radius: 6px;
    pointer-events: none;
  }
  #status .dot { display: inline-block; width: 8px; height: 8px;
    border-radius: 50%; margin-right: 6px; vertical-align: middle; }
  #status .on  { background: #4f4; }
  #status .off { background: #f44; }
  #controls {
    position: fixed; bottom: 14px; left: 10px; z-index: 100;
    font: 13px/1.4 'Consolas', monospace; color: #aaa;
    background: rgba(0,0,0,0.6); padding: 8px 14px; border-radius: 6px;
    display: flex; align-items: center; gap: 10px;
  }
  #controls input[type=range] { width: 160px; accent-color: #88c4a0; }
</style>
</head>
<body>

<div id="status">
  <span class="dot off" id="dot"></span>
  <span id="msg">Connecting&hellip;</span>
</div>
<div id="controls">
  <span>Global</span>
  <input type="range" id="globalSoft" min="0" max="100" value="40">
  <span style="margin-left:10px">Local</span>
  <input type="range" id="localSoft" min="0" max="100" value="50">
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

/* ---- Scene --------------------------------------------------- */
const scene    = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.Fog(0x000000, 300, 600);

const camera   = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 1, 1000);
camera.position.set(0, 70, 200);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

/* ---- Environment map (needed for transmission/reflections) --- */
const pmremGenerator = new THREE.PMREMGenerator(renderer);
scene.environment = pmremGenerator.fromScene(new RoomEnvironment()).texture;
pmremGenerator.dispose();

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0, 0);
controls.enableDamping = true;

/* ---- Lights -------------------------------------------------- */
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
dirLight.position.set(60, 120, 80);
scene.add(dirLight);
const backLight = new THREE.DirectionalLight(0xccddee, 1.0);
backLight.position.set(-40, -20, -60);
scene.add(backLight);

/* ---- Grid floor ---------------------------------------------- */
const grid = new THREE.GridHelper(300, 30, 0x333333, 0x1a1a1a);
grid.position.y = -60;
scene.add(grid);

/* ---- Sphere -------------------------------------------------- */
const SPHERE_R = 40;

const sphereGeo = new THREE.SphereGeometry(SPHERE_R, 64, 64);
const sphereMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  transmission: 0.95,
  thickness: 6,
  roughness: 0.05,
  metalness: 0,
  ior: 1.62,
  attenuationColor: new THREE.Color(0x88c4a0),
  attenuationDistance: 15,
  clearcoat: 0.3,
  clearcoatRoughness: 0.05,
  vertexColors: true
});
const sphere = new THREE.Mesh(sphereGeo, sphereMat);
scene.add(sphere);

const wireGeo = new THREE.SphereGeometry(SPHERE_R + 0.3, 32, 32);
const wireMat = new THREE.MeshBasicMaterial({
  color: 0xffffff, wireframe: true, transparent: true, opacity: 0.04,
  vertexColors: true
});
const wireframe = new THREE.Mesh(wireGeo, wireMat);
scene.add(wireframe);

/* Clone rest positions & add vertex color attributes */
function initDeformable(geo, baseColor) {
  const pos = geo.attributes.position;
  const rest = new Float32Array(pos.array.length);
  rest.set(pos.array);
  geo.userData.restPos = rest;

  const colors = new Float32Array(pos.count * 3);
  const c = new THREE.Color(baseColor);
  for (let i = 0; i < pos.count; i++) {
    colors[i * 3]     = c.r;
    colors[i * 3 + 1] = c.g;
    colors[i * 3 + 2] = c.b;
  }
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
}
initDeformable(sphereGeo, 0xc8e6d0);
initDeformable(wireGeo, 0xc8e6d0);

/* ---- Cursor (stylus tip) ------------------------------------- */
const cursorGroup = new THREE.Group();

const tipMat = new THREE.MeshPhongMaterial({ color: 0xffcc00, emissive: 0x664400 });
const tip = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 16), tipMat);
cursorGroup.add(tip);

scene.add(cursorGroup);

/* ---- Force arrow --------------------------------------------- */
const arrowDir = new THREE.Vector3(1, 0, 0);
const forceArrow = new THREE.ArrowHelper(arrowDir, new THREE.Vector3(), 1, 0xff2222);
forceArrow.visible = false;
scene.add(forceArrow);

/* ---- State --------------------------------------------------- */
let isTouching = false;
let targetPen = 0;
let currentPen = 0;
let contactDir = new THREE.Vector3();
let lastModel = '';
let lastForceMag = 0;
let lastPosStr = '';
const statusDot = document.getElementById('dot');
const statusMsg = document.getElementById('msg');

/* ---- Softness sliders ---------------------------------------- */
const globalEl = document.getElementById('globalSoft');
const localEl  = document.getElementById('localSoft');
let globalSoftness = parseInt(globalEl.value);
let localSoftness  = parseInt(localEl.value);

function softnessToK(s) {
  /* Exponential map: s=0 → K=0.50 (hard), s=100 → K=0.005 (very soft) */
  return 0.50 * Math.pow(0.01, s / 100);
}

function sendStiffness() {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ k: softnessToK(globalSoftness) }));
  }
}

globalEl.addEventListener('input', () => {
  globalSoftness = parseInt(globalEl.value);
  sendStiffness();
});

localEl.addEventListener('input', () => {
  localSoftness = parseInt(localEl.value);
});

/* ---- Deformation engine -------------------------------------- */
const BULGE_FRAC = 0.08;              /* volume-preservation bulge */
const baseColor = new THREE.Color(0xc8e6d0);   /* pale jade green */
const touchColor = new THREE.Color(0xf0f0e0);  /* warm glow at contact */

function deformSphere(geo, pen, dir, influenceAngle) {
  const restPos  = geo.userData.restPos;
  const posAttr  = geo.attributes.position;
  const colAttr  = geo.attributes.color;
  const verts    = posAttr.array;
  const colors   = colAttr.array;
  const count    = posAttr.count;

  const dx = dir.x, dy = dir.y, dz = dir.z;

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;
    const rx = restPos[i3], ry = restPos[i3 + 1], rz = restPos[i3 + 2];

    /* Vertex direction from origin (already on unit sphere * R) */
    const rLen = Math.sqrt(rx * rx + ry * ry + rz * rz);
    if (rLen < 1e-6) { continue; }
    const invR = 1.0 / rLen;
    const vx = rx * invR, vy = ry * invR, vz = rz * invR;

    /* Angle between vertex normal and contact direction */
    const cosA = vx * dx + vy * dy + vz * dz;
    const angle = Math.acos(Math.max(-1, Math.min(1, cosA)));

    let displacement = 0;

    if (angle < influenceAngle && pen > 0) {
      /* Cosine falloff: max at contact point, zero at edge of cone */
      const t = 1.0 - angle / influenceAngle;
      const falloff = 0.5 * (1.0 + Math.cos(Math.PI * (1.0 - t)));
      displacement = -pen * falloff;
    } else if (angle < influenceAngle * 1.6 && angle >= influenceAngle && pen > 0) {
      /* Small outward bulge just outside the cone (volume preservation) */
      const t = (angle - influenceAngle) / (influenceAngle * 0.6);
      const bulge = BULGE_FRAC * pen * Math.cos(t * Math.PI * 0.5);
      displacement = bulge;
    }

    /* Apply displacement along vertex normal */
    verts[i3]     = rx + vx * displacement;
    verts[i3 + 1] = ry + vy * displacement;
    verts[i3 + 2] = rz + vz * displacement;

    /* Color: blue (rest) -> pink (compressed) */
    const strain = Math.min(1.0, Math.abs(displacement) / Math.max(pen, 0.1));
    const c = baseColor.clone().lerp(touchColor, strain);
    colors[i3]     = c.r;
    colors[i3 + 1] = c.g;
    colors[i3 + 2] = c.b;
  }

  posAttr.needsUpdate = true;
  colAttr.needsUpdate = true;
  geo.computeVertexNormals();
}

function resetSphere(geo) {
  const restPos = geo.userData.restPos;
  const posAttr = geo.attributes.position;
  const colAttr = geo.attributes.color;
  posAttr.array.set(restPos);

  const colors = colAttr.array;
  for (let i = 0; i < colAttr.count; i++) {
    colors[i * 3]     = baseColor.r;
    colors[i * 3 + 1] = baseColor.g;
    colors[i * 3 + 2] = baseColor.b;
  }

  posAttr.needsUpdate = true;
  colAttr.needsUpdate = true;
  geo.computeVertexNormals();
}

/* ---- WebSocket ----------------------------------------------- */
let ws = null;
function connect() {
  ws = new WebSocket(`ws://${location.host}`);

  ws.onopen = () => {
    console.log('WebSocket connected');
    statusDot.className = 'dot on';
    statusMsg.textContent = 'Connected';
    sendStiffness();
  };

  ws.onclose = (e) => {
    console.log('WebSocket closed: code=' + e.code + ' reason=' + e.reason + ' clean=' + e.wasClean);
    statusDot.className = 'dot off';
    statusMsg.textContent = 'Disconnected \u2013 reconnecting\u2026';
    setTimeout(connect, 2000);
  };

  ws.onerror = (e) => { console.error('WebSocket error', e); ws.close(); };

  ws.onmessage = (e) => {
    let d;
    try { d = JSON.parse(e.data); } catch (err) {
      console.error('JSON parse error:', err, e.data);
      return;
    }

    /* Cursor position */
    cursorGroup.position.set(d.pos[0], d.pos[1], d.pos[2]);

    /* Touch / deformation state */
    isTouching = d.touch;
    if (d.touch && d.pen > 0) {
      targetPen = d.pen;
      /* Contact direction: from origin toward contact point (normalized) */
      const cx = d.cpt[0], cy = d.cpt[1], cz = d.cpt[2];
      const cLen = Math.sqrt(cx * cx + cy * cy + cz * cz);
      if (cLen > 1e-4) {
        contactDir.set(cx / cLen, cy / cLen, cz / cLen);
      }
    } else {
      targetPen = 0;
    }

    /* Force arrow */
    const fm = Math.sqrt(d.force[0]**2 + d.force[1]**2 + d.force[2]**2);
    lastForceMag = fm;
    if (fm > 0.01) {
      const dir = new THREE.Vector3(d.force[0], d.force[1], d.force[2]).normalize();
      const len = fm * 30;
      forceArrow.position.copy(cursorGroup.position);
      forceArrow.setDirection(dir);
      forceArrow.setLength(len, Math.min(len * 0.2, 8), Math.min(len * 0.1, 4));
      forceArrow.visible = true;
    } else {
      forceArrow.visible = false;
    }

    /* Cache for status text */
    lastModel = d.model;
    lastPosStr = `(${d.pos[0].toFixed(1)}, ${d.pos[1].toFixed(1)}, ${d.pos[2].toFixed(1)})`;
  };
}
connect();

/* ---- Resize -------------------------------------------------- */
addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ---- Animate ------------------------------------------------- */
let lastTime = performance.now();
(function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;

  controls.update();

  /* Spring-back interpolation for penetration */
  if (isTouching) {
    currentPen += (targetPen - currentPen) * Math.min(1, dt * 30);
  } else {
    /* Exponential decay when not touching */
    currentPen *= Math.exp(-dt * 12);
    if (currentPen < 0.01) currentPen = 0;
  }

  /* Apply deformation – local slider controls influence cone width */
  const influenceAngle = Math.PI / 6 + (Math.PI / 3) * (localSoftness / 100);
  if (currentPen > 0.01) {
    deformSphere(sphereGeo, currentPen, contactDir, influenceAngle);
    deformSphere(wireGeo, currentPen, contactDir, influenceAngle);
  } else {
    resetSphere(sphereGeo);
    resetSphere(wireGeo);
  }

  /* Status text */
  const forceStr = lastForceMag > 0.01 ? ` | Force: ${lastForceMag.toFixed(2)} N` : '';
  const penStr = currentPen > 0.1 ? ` | Indent: ${currentPen.toFixed(1)} mm` : '';
  if (lastModel) {
    statusMsg.textContent =
      `${lastModel} | ${isTouching ? 'TOUCHING' : 'Free'} | Pos: ${lastPosStr}${forceStr}${penStr}`;
  }

  renderer.render(scene, camera);
})();
</script>
</body>
</html>
