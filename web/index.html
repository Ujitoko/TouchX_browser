<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>TouchX Torus</title>
<style>
  body { margin: 0; overflow: hidden; background: #d4ba96; }
  #status {
    position: fixed; top: 10px; left: 10px; z-index: 100;
    font: 14px/1.4 'Consolas', monospace; color: #8a7a5a;
    background: rgba(255,255,255,0.35); padding: 8px 14px; border-radius: 6px;
    pointer-events: none;
  }
  #status .dot { display: inline-block; width: 8px; height: 8px;
    border-radius: 50%; margin-right: 6px; vertical-align: middle; }
  #status .on  { background: #6b4; }
  #status .off { background: #f44; }
  #controls {
    position: fixed; bottom: 14px; left: 10px; z-index: 100;
    font: 13px/1.4 'Consolas', monospace; color: #8a7a5a;
    background: rgba(255,255,255,0.35); padding: 8px 14px; border-radius: 6px;
    display: flex; align-items: center; gap: 10px;
  }
  #controls input[type=range] { width: 120px; accent-color: #6b4; }
</style>
</head>
<body>

<div id="status">
  <span class="dot off" id="dot"></span>
  <span id="msg">Connecting&hellip;</span>
</div>
<div id="controls">
  <span>Softness</span>
  <input type="range" id="stiffSlider" min="0" max="100" value="55">
  <span style="margin-left:8px">Spread</span>
  <input type="range" id="spreadSlider" min="10" max="100" value="50">
  <span style="margin-left:8px">Pointer</span>
  <input type="range" id="pointerSize" min="10" max="300" value="60">
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

/* ---- Constants (match server) -------------------------------- */
const DISC_RXZ = 35;   /* horizontal radius */
const DISC_RY  = 25;   /* vertical half-height */

/* ---- Scene --------------------------------------------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xd4ba96);

const camera = new THREE.PerspectiveCamera(40, innerWidth / innerHeight, 1, 1000);
camera.position.set(0, 80, 120);

const renderer = new THREE.WebGLRenderer({
  antialias: true,
  powerPreference: 'high-performance'
});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);

/* Environment map for realistic reflections */
const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment()).texture;

const orbitCtrl = new OrbitControls(camera, renderer.domElement);
orbitCtrl.target.set(0, 5, 0);
orbitCtrl.enableDamping = true;

/* ---- Lights -------------------------------------------------- */
scene.add(new THREE.AmbientLight(0xfff5e8, 0.4));

const keyLight = new THREE.DirectionalLight(0xfff0dd, 1.2);
keyLight.position.set(40, 80, 60);
scene.add(keyLight);

const fillLight = new THREE.DirectionalLight(0xeeddcc, 0.4);
fillLight.position.set(-30, 20, -40);
scene.add(fillLight);

/* ---- Green oblate sphere (deformable) ------------------------ */
const discGeo = new THREE.SphereGeometry(1, 32, 24);
/* Scale to oblate ellipsoid: wide in XZ, flat in Y */
{
  const pos = discGeo.attributes.position;
  for (let i = 0; i < pos.count; i++) {
    pos.setX(i, pos.getX(i) * DISC_RXZ);
    pos.setY(i, pos.getY(i) * DISC_RY);
    pos.setZ(i, pos.getZ(i) * DISC_RXZ);
  }
  pos.needsUpdate = true;
  discGeo.computeVertexNormals();
}

const discMat = new THREE.MeshStandardMaterial({
  color: 0x55cc33,
  roughness: 0.25,
  metalness: 0.05,
  envMapIntensity: 1.5
});
const disc = new THREE.Mesh(discGeo, discMat);
scene.add(disc);

/* Store rest positions and normals */
const restPos = new Float32Array(discGeo.attributes.position.array.length);
restPos.set(discGeo.attributes.position.array);
discGeo.userData.restPos = restPos;
const restNormals = new Float32Array(discGeo.attributes.normal.array.length);
restNormals.set(discGeo.attributes.normal.array);
discGeo.userData.restNormals = restNormals;
let geoDirty = false;

/* Dispose PMREM generator – no longer needed after env map creation */
pmrem.dispose();

/* Zero-allocation normal recomputation (avoids Three.js Vector3 objects) */
const _idxArr = discGeo.index.array;
function fastNormals(geo) {
  const pos = geo.attributes.position.array;
  const nrm = geo.attributes.normal.array;
  const idx = _idxArr;
  nrm.fill(0);
  for (let i = 0, il = idx.length; i < il; i += 3) {
    const a3 = idx[i] * 3, b3 = idx[i + 1] * 3, c3 = idx[i + 2] * 3;
    const abx = pos[b3] - pos[a3], aby = pos[b3+1] - pos[a3+1], abz = pos[b3+2] - pos[a3+2];
    const acx = pos[c3] - pos[a3], acy = pos[c3+1] - pos[a3+1], acz = pos[c3+2] - pos[a3+2];
    const nx = aby * acz - abz * acy;
    const ny = abz * acx - abx * acz;
    const nz = abx * acy - aby * acx;
    nrm[a3] += nx; nrm[a3+1] += ny; nrm[a3+2] += nz;
    nrm[b3] += nx; nrm[b3+1] += ny; nrm[b3+2] += nz;
    nrm[c3] += nx; nrm[c3+1] += ny; nrm[c3+2] += nz;
  }
  for (let i = 0, il = nrm.length; i < il; i += 3) {
    const len = Math.sqrt(nrm[i] * nrm[i] + nrm[i+1] * nrm[i+1] + nrm[i+2] * nrm[i+2]);
    if (len > 0) { const inv = 1 / len; nrm[i] *= inv; nrm[i+1] *= inv; nrm[i+2] *= inv; }
  }
  geo.attributes.normal.needsUpdate = true;
}

/* ---- Cursor -------------------------------------------------- */
const cursorGroup = new THREE.Group();
const tipMat = new THREE.MeshStandardMaterial({
  color: 0xeeeeee, roughness: 0.2, metalness: 0.1
});
const tip = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), tipMat);
cursorGroup.add(tip);

const pointerEl = document.getElementById('pointerSize');
tip.scale.setScalar(parseFloat(pointerEl.value) / 100 * 2);
pointerEl.addEventListener('input', () => {
  tip.scale.setScalar(parseFloat(pointerEl.value) / 100 * 2);
});
scene.add(cursorGroup);

/* ---- State --------------------------------------------------- */
let isTouching = false;
let targetPen  = 0;
let currentPen = 0;
let contactPt  = new THREE.Vector3();
const statusDot = document.getElementById('dot');
const statusMsg = document.getElementById('msg');

/* ---- Sliders ------------------------------------------------- */
const stiffEl  = document.getElementById('stiffSlider');
const spreadEl = document.getElementById('spreadSlider');
let stiffVal   = parseInt(stiffEl.value);
let spreadVal  = parseInt(spreadEl.value);

function stiffToK(s) {
  return 0.1 * Math.pow(50, s / 100);
}
function sendStiffness() {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ k: stiffToK(stiffVal) }));
  }
}
stiffEl.addEventListener('input', () => {
  stiffVal = parseInt(stiffEl.value);
  sendStiffness();
});
spreadEl.addEventListener('input', () => {
  spreadVal = parseInt(spreadEl.value);
});

/* ---- Ellipsoid deformation ----------------------------------- */
function deformDisc(geo, pen, cpt, influenceR) {
  const rest   = geo.userData.restPos;
  const posAttr = geo.attributes.position;
  const verts  = posAttr.array;
  const count  = posAttr.count;
  const cx = cpt.x, cy = cpt.y, cz = cpt.z;

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;
    const rx = rest[i3], ry = rest[i3 + 1], rz = rest[i3 + 2];

    /* 3D distance from vertex to contact point */
    const dx = rx - cx, dy = ry - cy, dz = rz - cz;
    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

    if (dist < influenceR && pen > 0) {
      const t = 1.0 - dist / influenceR;
      const falloff = t * t * (3 - 2 * t);

      /* Push vertex toward ellipsoid center (squish inward) */
      const rLen = Math.sqrt(rx * rx + ry * ry + rz * rz);
      if (rLen < 1e-6) { verts[i3]=rx; verts[i3+1]=ry; verts[i3+2]=rz; continue; }
      const invR = 1.0 / rLen;

      const disp = pen * falloff * 0.7;
      verts[i3]     = rx - rx * invR * disp;
      verts[i3 + 1] = ry - ry * invR * disp;
      verts[i3 + 2] = rz - rz * invR * disp;
    } else {
      verts[i3]     = rx;
      verts[i3 + 1] = ry;
      verts[i3 + 2] = rz;
    }
  }

  posAttr.needsUpdate = true;
  fastNormals(geo);
  geoDirty = true;
}

function resetDisc(geo) {
  if (!geoDirty) return;
  geo.attributes.position.array.set(geo.userData.restPos);
  geo.attributes.position.needsUpdate = true;
  geo.attributes.normal.array.set(geo.userData.restNormals);
  geo.attributes.normal.needsUpdate = true;
  geoDirty = false;
}

/* ---- WebSocket (binary protocol) ----------------------------- */
let ws = null;
let pendingBuf = null;  /* ArrayBuffer – only keep latest per frame */
let wsRecvCount = 0;

function processWsData() {
  if (!pendingBuf) return;
  try {
    const f = new Float64Array(pendingBuf);
    pendingBuf = null;
    cursorGroup.position.set(f[0], f[1], f[2]);
    const pen = f[3];
    if (pen > 0) {
      isTouching = true;
      targetPen  = pen;
      contactPt.set(f[4], f[5], f[6]);
    } else {
      isTouching = false;
      targetPen  = 0;
    }
  } catch (err) {
    console.error('processWsData error:', err,
                  'type:', typeof pendingBuf,
                  'size:', pendingBuf && pendingBuf.byteLength);
    pendingBuf = null;
  }
}

function connect() {
  wsRecvCount = 0;
  ws = new WebSocket(`ws://${location.host}`);
  ws.binaryType = 'arraybuffer';
  ws.onopen = () => {
    statusDot.className = 'dot on';
    statusMsg.textContent = 'Connected';
    console.log('WS opened');
    sendStiffness();
  };
  ws.onclose = (ev) => {
    console.log('WS close: code=' + ev.code + ' clean=' + ev.wasClean
                + ' msgs=' + wsRecvCount);
    statusDot.className = 'dot off';
    statusMsg.textContent = 'Disconnected (code ' + ev.code
                            + ', msgs=' + wsRecvCount + ')';
    setTimeout(connect, 2000);
  };
  ws.onerror = (e) => { console.error('WS error', e); };
  ws.onmessage = (e) => {
    pendingBuf = e.data;
    wsRecvCount++;
    if (wsRecvCount === 1) {
      console.log('First msg: type=' + (e.data instanceof ArrayBuffer ? 'bin' : 'text')
                  + ' size=' + (e.data.byteLength || e.data.length));
    }
  };
}
connect();

/* ---- Resize -------------------------------------------------- */
addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ---- Animate ------------------------------------------------- */
let lastTime = performance.now();

(function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;

  processWsData();
  orbitCtrl.update();

  /* Smooth penetration – squishy spring-back */
  if (isTouching) {
    currentPen += (targetPen - currentPen) * Math.min(1, dt * 25);
  } else {
    currentPen *= Math.exp(-dt * 5);
    if (currentPen < 0.01) currentPen = 0;
  }

  /* Disc deformation */
  const influenceR = 8 + 30 * (spreadVal / 100);
  if (currentPen > 0.01) {
    deformDisc(discGeo, currentPen, contactPt, influenceR);
  } else {
    resetDisc(discGeo);
  }

  renderer.render(scene, camera);
})();
</script>
</body>
</html>
